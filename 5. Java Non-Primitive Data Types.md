
## Overview

There are mainly **4 types** of reference data types:

1. **Class**
2. **String**
3. **Interface**
4. **Array**

## What is a Reference?

### Understanding References with Classes

When we create an object of a class:

```java
Employee emp = new Employee();
```

**How it works:**

- The `new` keyword allocates a memory block for the object in **Heap Memory**
- The variable `emp` holds a **reference** to the actual memory location
- The variable doesn't contain the object itself, just a pointer to it

```
Stack Memory          Heap Memory
┌─────────┐          ┌──────────────┐
│   emp   │─────────>│  Employee    │
│(reference)│        │   Object     │
└─────────┘          └──────────────┘
```

### Pass by Value in Java

- **Everything in Java is pass by value**
- Through reference variables, we achieve functionality similar to pointers in C++
- When we pass objects, we're passing the value of the reference (copy of the reference)

## 1. String

### String Immutability

- **Strings are immutable in Java**
- Once created, their value cannot be changed
- Any modification creates a new String object

### String Constant Pool

- Inside the Heap, there is a fixed memory space called **String Constant Pool** (SCP)
- String variables hold a reference to string literals in the String Constant Pool

### String Literal Example

```java
String s1 = "hello";
String s2 = "hello";
```

**Memory Representation:**

```
Stack                String Constant Pool (Heap)
┌────┐              ┌─────────┐
│ s1 │─────────────>│ "hello" │
└────┘        ┌─────>└─────────┘
              │
┌────┐        │
│ s2 │────────┘
└────┘
```

**Key Point:** Since strings are immutable, if the same string literal exists, both variables hold a reference to the **same** string literal in the String Constant Pool.

### String with `new` Keyword

```java
String s3 = new String("hello");
```

When created using `new` keyword, the string is stored as a **normal object in heap** (not in String Constant Pool).

## 2. Interface

### Interface Implementation Example

```java
public interface Person {
    // interface methods
}

public class Engineer implements Person {
    // implementation
}

public class Teacher implements Person {
    // implementation
}
```

### Creating Objects with Interface References

```java
public class Student {
    public static void main(String args[]) {
        Person softwareEngineer = new Engineer();
        Person teacher = new Teacher();
        
        Teacher teacher2 = new Teacher();
        Engineer softwareEngineer2 = new Engineer();
    }
}
```

**Memory Representation:**

```
Stack                                    Heap
┌───────────────────┐                  ┌──────────┐
│ softwareEngineer  │─────────────────>│ Engineer │
│ (Type: Person)    │                  │  Object  │
└───────────────────┘                  └──────────┘

┌───────────────────┐                  ┌──────────┐
│     teacher       │─────────────────>│ Teacher  │
│ (Type: Person)    │                  │  Object  │
└───────────────────┘                  └──────────┘
```

### Important Rules

✅ **Valid:** Store objects of a child class in a parent type variable

```java
Person teacher = new Teacher(); // Valid
```

✅ **Valid:** Store objects in the same class

```java
Teacher teacher = new Teacher(); // Valid
```

❌ **Invalid:** Cannot create an object of an interface

```java
Person person = new Person(); // WRONG - Interface cannot be instantiated
```

## 3. Array

### Definition

- A **sequence of memory** storing the **same datatype**
- Has a fixed **capacity**

### Array Declaration and Initialization

```java
// Method 1
int[] arr = new int[5];

// Method 2
int arr[] = new int[5];
```

### Memory Representation

```
Stack              Heap
┌─────┐           ┌────┬────┬────┬────┬────┐
│ arr │──────────>│ 10 │ 6  │ 10 │ 40 │ 20 │
└─────┘           └────┴────┴────┴────┴────┘
                    [0]  [1]  [2]  [3]  [4]
```

**Example:**

```java
arr[0] = 10;
arr[1] = 6;
arr[2] = 10;
arr[3] = 40;
arr[4] = 20;
```

### Array Features

- Arrays can be assigned in **multiple ways**
- Can be of **multiple types** (1D, 2D, etc.)
- Fixed size once created

## Wrapper Classes

### What are Wrapper Classes?

For each primitive data type, there is a corresponding **reference type** known as a **Wrapper Class**.

### Primitive to Wrapper Mapping

|Primitive|Wrapper Class|
|---|---|
|`int`|`Integer`|
|`char`|`Character`|
|`short`|`Short`|
|`byte`|`Byte`|
|`long`|`Long`|
|`float`|`Float`|
|`double`|`Double`|
|`boolean`|`Boolean`|

### Why Do We Need Wrapper Classes?

#### 1. Pass by Reference Advantage

- When using wrapper types, changes to the object reflect in memory
- Wrapper types store references (in heap), so modifications are preserved
- Primitive types are stored in stack, so modifications in methods don't persist

**Example:**

```java
Integer num = 10; // Stored in heap, can be modified by reference
```

#### 2. Collections Requirement

- **Collections work only with objects** (reference data types)
- Cannot use primitive types directly in collections
- Must use wrapper classes to work with collections

```java
ArrayList<Integer> list = new ArrayList<>(); // Valid
// ArrayList<int> list = new ArrayList<>();  // INVALID
```

### Autoboxing

**Definition:** Converting a primitive data type to its wrapper class automatically.

```java
int a = 10;
Integer a1 = a; // Autoboxing: primitive → wrapper
```

### Unboxing

**Definition:** Converting a wrapper class to its primitive type automatically.

```java
Integer x = 20;
int x1 = x; // Unboxing: wrapper → primitive
```

## Constant Variables

### Definition

- Variables whose **value cannot be changed** after initialization
- Created using the `final` keyword

### Syntax

```java
final int VAR = 10;
```

- The value of `VAR` cannot be changed after this assignment
- Attempting to change will result in a compilation error

### Static Final Variables

```java
static final int VAR = 10;
```

**Meaning:**

- `static`: Only **one copy** of the variable exists (shared across all instances)
- `final`: The value of `VAR` **cannot be changed**

### Naming Convention

Constant variables are typically named in **UPPERCASE** letters:

```java
static final int MAX_VALUE = 100;
static final String DEFAULT_NAME = "Unknown";
```

## Key Differences: Primitive vs Reference Types

|Aspect|Primitive Types|Reference Types|
|---|---|---|
|**Storage**|Stack memory|Heap memory (reference in stack)|
|**Contains**|Actual value|Reference to object|
|**Default Value**|0, false, '\u0000'|null|
|**Pass Behavior**|Pass by value|Pass by value (of reference)|
|**Collections**|Cannot be used directly|Can be used|
|**Modification**|Creates new value|Can modify object|

## Memory Summary

```
┌─────────────────────────────────────────┐
│           HEAP MEMORY                   │
│  ┌─────────────────────────────────┐   │
│  │   String Constant Pool          │   │
│  │   - "hello"                     │   │
│  │   - "world"                     │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │   Regular Objects               │   │
│  │   - Employee objects            │   │
│  │   - Arrays                      │   │
│  │   - Wrapper objects             │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│           STACK MEMORY                  │
│   - References to heap objects          │
│   - Primitive variables                 │
│   - Method calls                        │
└─────────────────────────────────────────┘
```

## Best Practices

1. **Use String literals** instead of `new String()` for better memory efficiency
2. **Use wrapper classes** when working with collections
3. **Declare constants** with `final` keyword and UPPERCASE naming
4. **Use autoboxing/unboxing** when needed, but be aware of performance in loops
5. **Understand pass-by-value** behavior to avoid unexpected results with references