

## What is a Variable?

A variable is a container which holds a value.

### How to Declare a Variable

```java
Datatype variableName = value;
```

**Examples:**

```java
int e = 1;
boolean myz = true;
```

## Java Language Characteristics

- **Static Typed Language**: We must mandatorily define the datatype of a variable
- **Strongly Typed Language**: There is a restriction on what value can be assigned to a variable

## Variable Naming Conventions

- Variable name is **case sensitive**
- Variable name can be any legal identifier (can contain Unicode letters & digits)
- Variable name can start with `$`, `_` (underscore), or a letter
- Variable name **cannot** be Java reserved keywords like:
    - `new`, `class`, `while`, `for`, `interface`, `int`, `float`, etc.
- Variable should be **small** if it contains only 1 word
- **Camel case** should be followed for multi-word variables
- For **constants**, variable name should be defined in **CAPITAL LETTERS**

## Types of Variables

```
Variables
├── Primitive Type
│   ├── char
│   ├── Integral Type
│   │   ├── byte
│   │   ├── short
│   │   ├── int
│   │   └── long
│   ├── Fractional Type
│   │   ├── float
│   │   └── double
│   └── boolean
└── Non-Primitive/Reference Type
    ├── class
    ├── interface
    ├── array
    └── String
```

## 8 Primitive Data Types

### 1. char

- **Size**: 2 bytes (16 bits)
- **Description**: Character representation of ASCII values
- **Range**: 0 to 65535 (i.e., '\u0000' to '\uffff')
- **Default Value**: '\u0000' (NUL)

### 2. byte

- **Size**: 1 byte (8 bits)
- **Representation**: Signed 2's complement
- **Range**: -128 to 127
- **Default Value**: 0

**Understanding 2's Complement:**

- 7 bits represent the number
- Last bit represents the sign (0 = positive, 1 = negative)
- 2's complement = 1's complement + 1

Example with 3:

```
+3: 0011
-3: 1101 (complement: 1100, then +1 = 1101)
+3 + (-3) = 0000 (i.e., 0)
```

### 3. short

- **Size**: 2 bytes (16 bits)
- **Representation**: Signed 2's complement
- **Range**: -32768 to 32767
- **Default Value**: 0

### 4. int

- **Size**: 4 bytes (32 bits)
- **Representation**: Signed 2's complement
- **Range**: -2³¹ to 2³¹-1
- **Default Value**: 0

### 5. long

- **Size**: 8 bytes (64 bits)
- **Representation**: Signed 2's complement
- **Range**: -2⁶³ to 2⁶³-1
- **Default Value**: 0
- **Example**: `long var = 100L;` (The 'L' signifies long type)

### 6. boolean

- **Size**: 1 bit
- **Values**: true or false
- **Default Value**: false

### 7. float & 8. double

_Discussed in detail in Fractional Types section below_

## Types of Type Conversion

### 1. Widening / Automatic Conversion

Automatic conversion when going from lower datatype to higher datatype:

```
byte (1 byte) → short (2 bytes) → int (4 bytes) → long (8 bytes)
```

**Example:**

```java
int var = 10;
long varLong = var; // Automatically converted int to long
```

### 2. Narrowing / Downcasting / Explicit Conversion

Going from higher datatype to lower datatype. Must be done manually.

**Example:**

```java
int integerVariable = 10;
byte byteVariable = (byte) integerVariable;
```

**Important Note**: If downcasting beyond range, it wraps around:

- If `integerVariable` is 128, `byteVariable` becomes -128 (next after 127)
- If `integerVariable` is 148, `byteVariable` becomes -108

### 3. Promotion During Expression

Happens internally during expression evaluation.

**Rules:**

- When expression value crosses the datatype range, promotion happens to higher datatype
- `byte` and `short` promote to `int`

**Example 1:**

```java
byte a = 2;
byte b = 127;
byte sum = a + b; // Won't work since range is crossing
int sum = a + b;  // Correct - result is int
```

**Example 2:**

```java
int a = 34;
double doubleVar = 6.0;
int sum = a + doubleVar;     // Gives error
double sum = a + doubleVar;  // Correct - int promoted to double
```

**Rule**: In an expression, if one datatype is of higher datatype, all others will automatically be converted to that higher datatype.

## Kinds of Variables

### 1. Member / Instance Variable

- Variable of the class
- Created when an object of the class is created
- Each object has its individual copy of member variable

### 2. Local Variable

- Variables defined inside a method
- Gets destroyed when method finishes execution

### 3. Static / Class Variable

- Only one copy of static/class variable exists
- Objects can access it using class name
- Shared across all instances

### 4. Method Parameters

- Variables passed to a method

### 5. Constructor Parameters

- Variables passed to a constructor

## Fractional Types in Detail

### How Float & Double Are Stored in Memory

**Float (32 bits):**

```
[1 Bit: Sign] [8 Bits: Exponent] [23 Bits: Mantissa/Significand]
```

- Sign bit: 0 = positive, 1 = negative
- Exponent: Stores the power
- Mantissa: Stores the significant digits

**Double (64 bits):** Similar structure but with more bits for precision

### Storing 4.125 as Float

**Step 1: Convert to Binary**

```
4 = 100 (binary)
0.125 = 0.001 (binary)
   0.125 × 2 = 0.25  → 0
   0.25 × 2 = 0.5    → 0
   0.5 × 2 = 1.0     → 1
Result: 4.125 = 100.001 (binary)
```

**Step 2: Normalize to (1.xxx) × 2^exponent**

```
100.001 = 1.00001 × 2²
```

(Moving 2 decimal places left adds 2 as power of 2)

**Step 3: Add Bias to Exponent**

```
Exponent = 2
Bias for float = 127
Biased exponent = 127 + 2 = 129
```

**Step 4: Assemble the Bits**

```
[0][10000001][00001000000000000000000]
 │      │              │
 Sign   Exponent(129)  Mantissa(00001)
```

### Converting Back from Binary to Float

**Formula:**

```
(-1)^sign × (1 + mantissa) × 2^(exponent - 127)
```

**Example:**

```
(-1)⁰ × (1 + 0.00001) × 2^(129-127)
= 1 × (1 + 0.03125) × 4
= 1 × 1.03125 × 4
= 4.125
```

### Storing 0.7 as Float

**Step 1: Convert to Binary**

```
0.7 × 2 = 1.4  → 1
0.4 × 2 = 0.8  → 0
0.8 × 2 = 1.6  → 1
0.6 × 2 = 1.2  → 1
0.2 × 2 = 0.4  → 0
0.4 × 2 = 0.8  → 0
0.8 × 2 = 1.6  → 1
(Keeps repeating)

Binary: 0.1011001100110... (repeating)
```

**Step 2: Normalize**

```
1.011001100110... × 2^(-1)
```

(Decimal shifted 1 position to right)

**Step 3: Add Bias**

```
-1 + 127 = 126
```

**Step 4: Assemble**

```
[0][01111110][01100110011001100110011]
```

**Converting Back:**

```
(-1)⁰ × (1 + 0.399414062) × 2^(126-127)
= 1 × 1.399414062 × 0.5
= 0.699707031
```

### Precision Issue

The stored value (0.699707031) is **less than** 0.7 due to limited precision.

**Solution**: Use `BigDecimal` instead of `float` for precise decimal calculations.

## Key Takeaways

- Java has 8 primitive types: byte, short, int, long, float, double, char, boolean
- Automatic widening happens when converting to larger types
- Explicit casting required for narrowing conversions
- Expression evaluation may promote types automatically
- Float/double use IEEE 754 standard with potential precision issues
- Use BigDecimal for financial calculations requiring exact precision