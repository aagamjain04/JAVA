## Types of Classes

### Abstract Classes

**Abstract Class**: A class that contains at least one abstract method and cannot be instantiated directly.

#### Components:

- **Abstract Method**: Method without implementation (just declaration)
- **Non-Abstract Method**: Regular method with implementation
- **Concrete Class**: Class that implements all abstract methods

#### Example Structure:

```java
// Abstract class
abstract class Vehicle {
    abstract void start();  // Abstract method
    
    void stop() {           // Non-abstract method
        System.out.println("Vehicle stopped");
    }
}

// Another abstract class inheriting
abstract class LuxuryCar extends Vehicle {
    abstract void addLuxuryFeatures();  // Additional abstract method
}

// Concrete class - implements all abstract methods
class BMW extends LuxuryCar {
    void start() {
        System.out.println("BMW started");
    }
    
    void addLuxuryFeatures() {
        System.out.println("Added luxury features");
    }
}
```

#### Object Class Reference

Since `Object` is the parent class of every class in Java, any object reference can be kept in Object type:

```java
Person person = new Person();
Object obj = person;  // Valid - child class reference in parent class
```

---

## Nested Classes

### 1. Static Nested Class

**Key Points**:

- Can only access static variables/methods of outer class
- Can be accessed directly with the class name
- No need for outer class object

#### Example:

```java
class OuterClass {
    static int staticVar = 10;
    int instanceVar = 20;
    
    static class StaticInner {
        void display() {
            System.out.println(staticVar);     // Valid
            // System.out.println(instanceVar); // Error - cannot access instance variable
        }
    }
}

// Creating object
OuterClass.StaticInner inner = new OuterClass.StaticInner();
inner.display();
```

### 2. Non-Static Inner Class

**Key Points**:

- Can access both static and non-static members of outer class
- Requires outer class object to be instantiated

#### Example:

```java
class OuterClass {
    int outerVar = 100;
    
    class InnerClass {
        void display() {
            System.out.println("Outer variable: " + outerVar);
        }
    }
}

// Creating object
OuterClass outer = new OuterClass();
OuterClass.InnerClass inner = outer.new InnerClass();
inner.display();
```

### 3. Local Inner Class

**Key Points**:

- Defined inside a method or block
- Scope limited to that block only
- Cannot be accessed outside the block

#### Example:

```java
class OuterClass {
    void myMethod() {
        class LocalInner {
            void display() {
                System.out.println("Local inner class");
            }
        }
        
        LocalInner local = new LocalInner();
        local.display();
    }
    // LocalInner not accessible here
}
```

### Access Modifiers for Nested Classes

Nested classes can have any access modifier: `public`, `private`, `protected`, `default`, `package-protected`

#### Private Nested Class Example:

```java
class OuterClass {
    private class PrivateInner {
        void display() {
            System.out.println("Private inner class");
        }
    }
    
    void createInner() {
        PrivateInner inner = new PrivateInner();  // Created within same class
        inner.display();
    }
}
```

### Inheritance in Nested Classes

#### Example 1: Inner class inheriting another inner class

```java
class Outer {
    class Inner1 {
        void method1() { }
    }
    
    class Inner2 extends Inner1 {
        void method2() { }
    }
}
```

#### Example 2: Static inner class inherited by different class

```java
class Outer {
    static class StaticInner {
        void display() { }
    }
}

class Another extends Outer.StaticInner {
    void anotherMethod() { }
}
```

#### Example 3: Non-static inner class inherited by different class

```java
class Outer {
    class Inner {
        void display() { }
    }
}

class Another extends Outer.Inner {
    Another(Outer outer) {
        outer.super();  // Need to call outer class constructor
    }
}
```

---

## Anonymous Inner Classes

**Definition**: A class without a name that is declared and instantiated at the same time.

### Example with Abstract Class:

```java
abstract class Animal {
    abstract void makeSound();
}

// Anonymous inner class
Animal animal = new Animal() {
    void makeSound() {
        System.out.println("Some sound");
    }
};

animal.makeSound();
```

**What happens behind the scenes:**

1. A subclass is created (name decided by compiler)
2. Object of subclass is created and its reference assigned to the variable

### Example with Interface:

```java
interface Greeting {
    void greet();
}

Greeting greeting = new Greeting() {
    public void greet() {
        System.out.println("Hello!");
    }
};

greeting.greet();
```

---

## Generic Classes

**Purpose**: Write classes in a generic manner to avoid typecasting required with Object class.

### Without Generics (Using Object):

```java
class Point {
    Object value;
    
    Point(Object value) {
        this.value = value;
    }
    
    void compare() {
        if ((int)value > 1) {  // Need to typecast
            System.out.println("Greater");
        }
    }
}
```

**Issue**: Need to typecast based on usage

### With Generics:

```java
class Point<T> {
    T value;
    
    Point(T value) {
        this.value = value;
    }
}

// Creating objects
Point<Integer> p1 = new Point<>(10);      // T is replaced by Integer
Point<String> p2 = new Point<>("Hello");  // T is replaced by String
```

**Note**: Generic type `<T>` can be any non-primitive object (Integer, String, Custom classes, etc.)

### Inheritance in Generic Classes

#### 1. Non-Generic Subclass

```java
class GenericParent<T> {
    T value;
}

// Must specify type while extending
class NonGenericChild extends GenericParent<Integer> {
    // Type is fixed as Integer
}
```

#### 2. Generic Subclass

```java
class GenericParent<T> {
    T value;
}

class GenericChild<T> extends GenericParent<T> {
    // Type can be specified at object creation
}

GenericChild<String> child = new GenericChild<>();
```

### Multiple Generic Parameters

```java
class Pair<T1, T2> {
    T1 first;
    T2 second;
    
    Pair(T1 first, T2 second) {
        this.first = first;
        this.second = second;
    }
}

// Both syntaxes are valid:
Pair<String, Integer> pair1 = new Pair<String, Integer>("Age", 25);
Pair<String, Integer> pair2 = new Pair<>("Age", 25);  // Diamond operator
```

**Note**: You can create as many generic parameters as needed: `ClassName<T1, T2, T3, ..., Tn>`

### Generic Methods

To make a method generic, put the generic type before the return type:

```java
class Utility {
    // Generic method with single parameter
    public <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    
    // Generic method with multiple parameters
    public <T, U> void display(T first, U second) {
        System.out.println(first + " " + second);
    }
}

// Usage
Utility util = new Utility();
Integer[] nums = {1, 2, 3};
util.printArray(nums);
```

### Raw Type Objects

**Definition**: Generic class/interface without any type argument.

```java
Point p = new Point(10);  // No type specified
```

**What happens**: Internally passes `Object` as parameterized type. Therefore, `Point p` is a raw type object.

### Bounded Generics

**Purpose**: Restrict what objects can be passed as type parameter.

#### Upper Bound (extends)

```java
// Only Number or its subclasses allowed
class Calculator<T extends Number> {
    T value;
    
    Calculator(T value) {
        this.value = value;
    }
}

Calculator<Integer> calc1 = new Calculator<>(10);  // ✓ Valid (Integer extends Number)
Calculator<Double> calc2 = new Calculator<>(10.5);  // ✓ Valid (Double extends Number)
// Calculator<String> calc3 = new Calculator<>("Hi"); // ✗ Error (String is not a Number)
```

**Valid subclasses of Number**: `Integer`, `Double`, `Float`, `Long`, `Short`, `Byte`

#### Upper Bound with Interface

```java
class MyClass<T extends Comparable<T>> {
    T value;
}

// Only classes implementing Comparable can be used
```

#### Multiple Bounds

```java
class MyClass<T extends Number & Comparable<T>> {
    T value;
}
```

### Wildcards

**Purpose**: Provide flexibility when exact type is not known.

#### Problem Without Wildcards:

```java
class Vehicle { }
class Bus extends Vehicle { }
class Car extends Vehicle { }

List<Bus> busList = new ArrayList<>();
List<Vehicle> vehicleList = new ArrayList<>();

// busList = vehicleList;     // ✗ Invalid
// vehicleList = busList;     // ✗ Invalid
```

**Why invalid?**

- `busList = vehicleList`: busList can only store Bus objects
- `vehicleList = busList`: vehicleList can store both Bus and Car, but busList can only contain Bus

#### Upper Bound Wildcard (? extends)

```java
void processVehicles(List<? extends Vehicle> list) {
    for (Vehicle v : list) {
        // Process vehicle
    }
}

// Can pass Vehicle or any subclass list
processVehicles(vehicleList);  // ✓ Valid
processVehicles(busList);      // ✓ Valid
processVehicles(carList);      // ✓ Valid
```

#### Lower Bound Wildcard (? super)

```java
void addVehicles(List<? super Vehicle> list) {
    list.add(new Vehicle());
    list.add(new Bus());
}

List<Vehicle> vehicleList = new ArrayList<>();
List<Object> objectList = new ArrayList<>();

addVehicles(vehicleList);  // ✓ Valid
addVehicles(objectList);   // ✓ Valid (Object is superclass of Vehicle)
```

#### Unbounded Wildcard (?)

```java
void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```

**Use case**: When method only uses methods provided by Object class.

### Wildcards vs Generic Type Parameters

```java
// Wildcard method - less restrictive
void copyWildcard(List<? extends Number> source, List<? super Number> destination) {
    // Can use different types for source and destination
}

// Generic method - more restrictive
<T extends Number> void copyGeneric(T source, T destination) {
    // Both parameters must be same type
}

// Usage
List<Integer> intList = new ArrayList<>();
List<Number> numList = new ArrayList<>();

copyWildcard(intList, numList);  // ✓ Valid (different types allowed)
// copyGeneric(intList, numList);   // ✗ Error (same type required)
```

**Key Differences**:

1. Wildcards are less restrictive - can accept different types
2. Wildcards support `super` keyword for lower bounds
3. Generic methods require same type for all occurrences of type parameter

---

## Type Erasure

**Definition**: When bytecode is generated, generic type information is replaced by actual values.

### Generic Class Erasure

**Before compilation:**

```java
class Box<T> {
    T value;
}
```

**After compilation (bytecode):**

```java
class Box {
    Object value;  // T replaced by Object
}
```

### Generic Class Bound Type Erasure

**Before compilation:**

```java
class Box<T extends Number> {
    T value;
}
```

**After compilation:**

```java
class Box {
    Number value;  // T replaced by Number (the bound)
}
```

### Generic Method Erasure

**Before compilation:**

```java
<T> void print(T value) {
    System.out.println(value);
}
```

**After compilation:**

```java
void print(Object value) {
    System.out.println(value);
}
```

### Generic Bound Type Method Erasure

**Before compilation:**

```java
<T extends Comparable<T>> void sort(T value) {
    // sorting logic
}
```

**After compilation:**

```java
void sort(Comparable value) {
    // sorting logic
}
```

---

## Summary

- **Abstract Classes**: Cannot be instantiated, contain abstract methods
- **Nested Classes**: Classes within classes (static, non-static, local)
- **Anonymous Classes**: Classes without names, declared and instantiated together
- **Generic Classes**: Type-safe classes that avoid typecasting
- **Bounded Generics**: Restrict type parameters using `extends`
- **Wildcards**: Provide flexibility with unknown types (`?`, `? extends`, `? super`)
- **Type Erasure**: Generics removed during compilation, replaced by bounds or Object