
## Overview

JVM manages two types of memory:

1. **Stack Memory**
2. **Heap Memory**

---

## Stack Memory

### Characteristics

- Stores temporary variables and separate memory blocks for methods
- Stores primitive data types
- Stores references to heap objects:
    - Strong reference
    - Weak reference
    - Soft reference
- Each thread has its own stack memory
- Variables within a scope are only visible within that scope
- When a variable goes out of scope, it gets deleted from the stack (LIFO order)
- When stack memory is full, throws `java.lang.StackOverflowError`

---

## Heap Memory

### Characteristics

- Stores objects
- No specific order for memory allocation
- Garbage Collector deletes unreferenced objects from the heap
    - Uses **Mark & Sweep Algorithm**
    - Types of Garbage Collectors: Serial GC, Parallel GC, G1, CMS (Concurrent Mark & Sweep)
- Heap memory is shared among all threads

---

## Memory Allocation Example

### Initial Setup

Consider a class with various data types:

- Primitive datatype
- Object
- String literal
- Reference to object

```
┌─────────────────────┐
│       STACK         │
├─────────────────────┤
│ main() {            │
│   primitiveVar = 10 │
│   personObj ────────┼──┐
│   stringLiteral ────┼──┼──┐
│ }                   │  │  │
│                     │  │  │
│ memObj ─────────────┼──┼──┼──┐
│                     │  │  │  │
│ memoryManagement() {│  │  │  │
│   personObj2 ───────┼──┼──┼──┼──┐
│   stringLiteral2 ───┼──┼──┼──┼──┼──┐
│   stringLiteral3 ───┼──┼──┼──┼──┼──┼──┐
│ }                   │  │  │  │  │  │  │
└─────────────────────┘  │  │  │  │  │  │
                         │  │  │  │  │  │
┌────────────────────────┼──┼──┼──┼──┼──┼──┐
│        HEAP            │  │  │  │  │  │  │
├────────────────────────┼──┼──┼──┼──┼──┼──┤
│ Person Object      <───┘  │  │  │  │  │  │
│ memoryManagement obj  <───┘  │  │  │  │  │
│ Person Object2     <──────────┘  │  │  │  │
└──────────────────────────────────┼──┼──┼──┘
                                   │  │  │
┌──────────────────────────────────┼──┼──┼──┐
│     STRING POOL                  │  │  │  │
├──────────────────────────────────┼──┼──┼──┤
│ "z4"                         <───┘  │  │  │
│ "4"                          <──────┘  │  │
│ "24"                         <─────────┘  │
└───────────────────────────────────────────┘
```

### After memoryManagementTest() Method Ends

When the closing bracket of memoryManagementTest() is encountered, its scope ends and the stack portion is deleted in LIFO order:

```
┌─────────────────────┐
│       STACK         │
├─────────────────────┤
│ main() {            │
│   primitiveVar = 10 │
│   personObj ────────┼──┐
│   stringLiteral ────┼──┼──┐
│ }                   │  │  │
│                     │  │  │
│ memObj ─────────────┼──┼──┼──┐
└─────────────────────┘  │  │  │
                         │  │  │
┌────────────────────────┼──┼──┼──┐
│        HEAP            │  │  │  │
├────────────────────────┼──┼──┼──┤
│ Person Object      <───┘  │  │  │
│ memoryManagement obj  <───┘  │  │
│ Person Object2                │  │
└───────────────────────────────┼──┘
                                │
┌───────────────────────────────┼──┐
│     STRING POOL                │  │
├────────────────────────────────┼──┤
│ "24"                       <───┘  │
│ "z4"                              │
│ "4"                               │
└───────────────────────────────────┘
```

### After main() Method Ends

When main() ends, its stack portion is deleted in LIFO order:

```
┌─────────────────────┐
│       STACK         │
│     (EMPTY)         │
└─────────────────────┘

┌─────────────────────┐
│        HEAP         │
├─────────────────────┤
│ Person Object       │
│ memoryManagement obj│
│ Person Object2      │
└─────────────────────┘

┌─────────────────────┐
│     STRING POOL     │
├─────────────────────┤
│ "24"                │
│ "z4"                │
│ "4"                 │
└─────────────────────┘
```

### After Garbage Collection

Stack is cleared and all references are deleted, but objects remain in the heap. **Garbage Collector** deletes all unreferenced objects from the heap:

```
┌─────────────────────┐
│       STACK         │
│     (EMPTY)         │
└─────────────────────┘

┌─────────────────────┐
│        HEAP         │
│     (cleaned by GC) │
└─────────────────────┘

┌─────────────────────┐
│     STRING POOL     │
├─────────────────────┤
│ "24"                │
│ "z4"                │
│ "4"                 │
└─────────────────────┘
```

### Garbage Collector Notes

- Runs periodically; JVM controls when to run GC
- Can request GC using `System.gc()` but doesn't guarantee execution
- This is called **automatic memory management**
- Frequency of GC is directly proportional to heap memory fullness

---

## Types of References

### 1. Strong Reference

- A variable in stack referencing an object in heap memory
- As long as the reference exists, GC cannot delete the object from heap

**Example:**

```java
Person pObj = new Person();
```

```
┌─────────────────────┐
│       STACK         │
├─────────────────────┤
│ pObj ───────────────┼──┐
└─────────────────────┘  │
                         │
┌────────────────────────┼──┐
│        HEAP            │  │
├────────────────────────┼──┤
│ Person Object      <───┘  │
│ (Strong Reference)        │
└───────────────────────────┘
```

### 2. Weak Reference

- Reference exists to an object in heap
- As soon as GC runs, the object is deleted even if a variable is referencing it
- The stack variable will get `null` if it tries to access the object post-GC

**Example:**

```java
WeakReference<Person> weakPObj = new WeakReference<Person>(new Person());
```

```
┌─────────────────────┐
│       STACK         │
├─────────────────────┤
│ pObj ───────────────┼──┐  (Strong)
│                     │  │
│ weakPObj -------────┼──┼──┐  (Weak - dashed)
└─────────────────────┘  │  │
                         │  │
┌────────────────────────┼──┼──┐
│        HEAP            │  │  │
├────────────────────────┼──┼──┤
│ Person Object      <───┘  │  │
│                           │  │
│ Person Object      <------┘  │
│ (After GC: DELETED)           │
└───────────────────────────────┘
```

### 3. Soft Reference

- Type of weak reference
- Object is deleted **only when there is shortage of space** in heap
- GC is allowed to delete soft references but keeps the object if sufficient space exists

### Changing References

References can be changed by assigning a new variable:

```java
Person obj1 = new Person(); // created new object
Person obj2 = new Person(); // created another object
obj1 = obj2;
```

Now `obj1` will reference the object of `obj2` in heap, and when GC runs, the earlier object that `obj1` was referring to will be deleted.

---

## Heap Memory Structure

Heap memory is divided into:

1. **Young Generation**
2. **Old Generation**
3. **Non-Heap (Metaspace)**

```
┌──────────────────────────────────────────────────────────────┐
│                         HEAP MEMORY                          │
├──────────────────────────────┬───────────────┬───────────────┤
│    YOUNG GENERATION          │      OLD      │   METASPACE   │
│                              │  GENERATION   │   (NON-HEAP)  │
├───────────┬─────────┬────────┤               │               │
│   EDEN    │   S0    │   S1   │               │               │
│           │(Survivor)(Survivor)              │               │
└───────────┴─────────┴────────┴───────────────┴───────────────┘
```

### Notes:

- Before Java 7: Called "PermGen" (Permanent Generation)
- Java 8+: Called "Metaspace" (expandable)
- Young Generation divided into: **Eden**, **S0** (Survivor 0), **S1** (Survivor 1)

---

## Object Lifecycle in Heap

### Step 1: Object Creation

When new objects are created, they go to **Eden** first.

Example: Create 5 objects (O1, O2, O3, O4, O5)

```
┌──────────────────────────────────────────────────────┐
│             YOUNG GENERATION    │  OLD GENERATION    │
├─────────────────────────────────┼────────────────────┤
│  EDEN          S0        S1     │                    │
│  O1 O2 O3                       │                    │
│  O4 O5                          │                    │
└─────────────────────────────────┴────────────────────┘
```

### Step 2: First GC Run (Minor GC)

Assume O1 and O5 have no references.

**GC uses Mark & Sweep Algorithm:**

1. **Mark**: Mark objects with no references (O1, O5)
2. **Sweep**:
    - Remove dereferenced objects (O1, O5)
    - Move survivor objects to one survivor space (S0 or S1)
    - Add age to objects

```
┌──────────────────────────────────────────────────────┐
│             YOUNG GENERATION    │  OLD GENERATION    │
├─────────────────────────────────┼────────────────────┤
│  EDEN          S0        S1     │                    │
│               O2(age:1)         │                    │
│               O3(age:1)         │                    │
│               O4(age:1)         │                    │
└─────────────────────────────────┴────────────────────┘
```

This is called **Minor GC** (happens frequently and quickly).

### Step 3: Create More Objects

Create O6 and O7:

```
┌──────────────────────────────────────────────────────┐
│             YOUNG GENERATION    │  OLD GENERATION    │
├─────────────────────────────────┼────────────────────┤
│  EDEN          S0        S1     │                    │
│  O6 O7        O2(age:1)         │                    │
│               O3(age:1)         │                    │
│               O4(age:1)         │                    │
└─────────────────────────────────┴────────────────────┘
```

### Step 4: Second GC Run

Assume O4 and O7 have no references.

GC will:

- Mark O4 and O7
- Delete O4 and O7
- Move survivors to S1 with incremented ages

```
┌──────────────────────────────────────────────────────┐
│             YOUNG GENERATION    │  OLD GENERATION    │
├─────────────────────────────────┼────────────────────┤
│  EDEN          S0        S1     │                    │
│                          O2(age:2)                   │
│                          O3(age:2)                   │
│                          O6(age:1)                   │
└─────────────────────────────────┴────────────────────┘
```

**Note:** At any time, Eden is completely free after GC, and one survivor space (S0 or S1) is free. Data is placed alternatively in S0 and S1 with respective ages.

### Step 5: Create More Objects & Set Threshold

Create O8 and O9. Set **threshold age = 3**.

```
┌──────────────────────────────────────────────────────┐
│             YOUNG GENERATION    │  OLD GENERATION    │
├─────────────────────────────────┼────────────────────┤
│  EDEN          S0        S1     │                    │
│  O8 O9                  O2(age:2)                    │
│                          O3(age:2)                   │
│                          O6(age:1)                   │
└─────────────────────────────────┴────────────────────┘
```

### Step 6: Third GC Run with Promotion

Assume O2 and O8 have no references.

**Promotion**: Objects with age 3 are moved to **Old Generation**.

GC will:

- Mark O2 and O8
- Delete O2 and O8
- Move survivors (O3, O9) to S0
- **Promote O3** (age becomes 3) to Old Generation

```
┌──────────────────────────────────────────────────────┐
│             YOUNG GENERATION    │  OLD GENERATION    │
├─────────────────────────────────┼────────────────────┤
│  EDEN          S0        S1     │  O3                │
│               O9(age:1)         │                    │
│               O6(age:2)         │                    │
└─────────────────────────────────┴────────────────────┘
```

---

## Old Generation

### Major GC

- GC in Old Generation is called **Major GC**
- Runs **less periodically** compared to Young Generation
- Objects in Old Generation are:
    - Larger objects
    - Used frequently
    - May have many references pointing to them

---

## Metaspace (Non-Heap)

### Contains:

- **Class Variables**
- **Class Metadata** (information about classes from which objects can be created)
- **Constants**

### History:

- **Before Java 8**: Fixed space called "PermGen" (Permanent Generation)
    - Non-expandable
    - Threw `OutOfMemoryError` when filled
- **Java 8+**: Metaspace
    - Separate from heap
    - Expandable
    - Prevents memory errors from fixed size limitations

---

## Garbage Collector Algorithms

### 1. Mark & Sweep Algorithm

Already discussed in object lifecycle above.

### 2. Mark & Sweep with Compact Memory

Once GC runs, remaining objects are placed in **sequential memory blocks**, leaving another sequential block free for new objects.

```
BEFORE:
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ O1 │ O2 │ O3 │ O4 │ O5 │ O6 │ O7 │ O8 │
└────┴────┴────┴────┴────┴────┴────┴────┘

MARKED FOR DELETION (O2, O4, O6):
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ O1 │[X] │ O3 │[X] │ O5 │[X] │ O7 │ O8 │
└────┴────┴────┴────┴────┴────┴────┴────┘

AFTER DELETION:
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ O1 │    │ O3 │    │ O5 │    │ O7 │ O8 │
└────┴────┴────┴────┴────┴────┴────┴────┘

AFTER COMPACTION:
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ O1 │ O3 │ O5 │ O7 │ O8 │    │    │    │
└────┴────┴────┴────┴────┴────┴────┴────┘
        (Sequential blocks)    (Free space)
```

---

## Versions of Garbage Collectors

### 1. Serial GC

**Characteristics:**

- Only **one GC thread** for both Minor and Major GC
- **Disadvantage**: Slower due to single thread
- GC is expensive (all application threads pause during GC)

**Use Case:** Small applications with single-threaded environments

---

### 2. Parallel GC

**Characteristics:**

- **Multiple parallel threads** running based on CPU configuration
- GC works faster
- Application threads paused for **less time**

**Use Case:** Better for multi-core systems

- **Default in Java 8**

---

### 3. Concurrent Mark & Sweep (CMS)

**Characteristics:**

- GC tries to run **concurrently with application threads**
- **No guarantee** of always being concurrent
- **No memory compaction**

**Use Case:** Applications requiring low pause times

---

### 4. G1 Garbage Collector (Garbage First)

**Characteristics:**

- **Better version** of CMS
- Tries **not to stop/pause** application threads
- **Supports memory compaction**
- Minimal pause time, increasing throughput and decreasing latency

**Use Case:** Large heap sizes, predictable pause times

- **Default in latest Java versions**

---

## Summary Table

|Feature|Stack|Heap|
|---|---|---|
|**Stores**|Primitives, references, method calls|Objects|
|**Thread Access**|Thread-specific|Shared across threads|
|**Lifecycle**|LIFO, automatic cleanup|GC managed|
|**Error**|StackOverflowError|OutOfMemoryError|
|**Order**|Ordered (LIFO)|Unordered|

---

## Key Takeaways

1. **Stack**: Fast, thread-local, stores primitives and references
2. **Heap**: Shared, stores objects, managed by GC
3. **Young Generation**: New objects, frequent Minor GC
4. **Old Generation**: Long-lived objects, infrequent Major GC
5. **Metaspace**: Class metadata, expandable (Java 8+)
6. **GC Types**: Serial → Parallel → CMS → G1 (increasing sophistication)
7. **References**: Strong (default) → Soft (memory-sensitive) → Weak (GC-eligible)

---

## Performance Tips

- Use appropriate GC based on application needs
- Monitor heap usage and adjust sizes
- Understand object lifecycle to prevent memory leaks
- Latest Java versions with G1 GC provide best balance of throughput and latency